

/* the universal selector, 
and it sets a style for all of the elements 
of an HTML page. */
* {
    /* browsers put padding and margin on many elements by default,
    this takes all of that off at the beginning */
    margin: 0;
    padding: 0;

    /* The border-box value calculates the height and 
    width of the element
     by including the border and padding additions 
     to the content box. Helps keep content from going
     off the screen*/
    box-sizing: border-box;
}


body {
    color: #39a6b2;
    font-family: Helvetica, Arial, sans-serif;
    
}

/* header style */

header {
    /* padding top bottom, left right */
    padding: 20px 35px;
    background-color: #39a6b2;
    /* check google docs css flexbox. This makes all direct child elements
    of the header (h1, nav) flex items in the header.
    Adding flexbox can override the behavior of block elements, and 
    display them side by side. overrides display property and changes direct 
    child elements to "flex"
    */
    display: flex;
    /* google docs css flexbox, this property can only be used when the
    display value of the element or parent element is flex.
    This property declaration puts all of the unused space in 
    the <header> between the two elements, with the space-between value. 
    It determines the unused space by adding up the border-width, margin, 
    padding, and content of each child element. If these don't add up to 100% 
    of the parent, then whatever is left over is considered unused.
    */
    justify-content: space-between;
    /* By default, the value of flex-wrap is set to none, so we need 
    to explicitly tell it to wrap to the next line if the screen width is smaller
    or the child elements are too big for the screen.

    This will cause the nav element to break to the next line on smaller screens, 
    but all the nav
    items break in weird places. We can change this in the nav ul element css
    */
    flex-wrap: wrap;
}

header h1 {
    font-weight: bold;
    font-size: 36px;
    color: #fce138;
    margin: 0;
}

header a {
    text-decoration: none;
    color: #fce138;
}

header nav {
    margin: 7px 0;
}

header nav ul {
    /* makes the li items go side by side, turns into flex items,
    since they are direct children of the ul element
    */
    display: flex;
    /* if screen is small (mobile) wrap content to other line if needed */
    flex-wrap: wrap;
    justify-content: space-between;
    /* vertically center the content for smaller screens */
    align-items: center;
    /* The other property we added, list-style, sets how 
    a list item is styled (bullet points, dashes, etc.) and positioned 
    (indented or outdented). We gave it a value of none to hide 
    the bullet points, because we're changing some of the styles 
    for the <header>. These changes might make the bullet points visible, 
    which we don't want. 
    */
    list-style: none;
}

header nav ul li a {
    margin: 0 30px;
    font-weight: lighter;
    /* vw stands for viewport width. Font size is determined by the width
    of the viewport. In this case we want the font size to be roughly
    1.55% of the windows overall width. This means that if the browser grows 
    or shrinks, that size will change relative to the new overall width.
    */
    font-size: 1.55vw;
}

/* footer style */

footer {
    background: #fce138;
    width: 100%;
    padding: 40px 35px;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

footer h2 {
    color: #024e76;
    font-size: 30px;
    margin: 0;
}

footer div {
    /* vertical space between lines of text */
    line-height: 1.5; 
    text-align: right;
}

footer a {
    color: #024e76;
}

section {
    padding: 60px;
}

/* Hero style start */
.hero {
    /* 
        The height property fixed at 600px gives an exact size 
        of the section, which is important in this context to allow 
        room for the sign-up form.

        height: 600px;
        REPLACED WITH FLEXBOX
        SEE HEADER CSS FOR FLEXBOX INFORMATION
        TAKES THE 2 DIRECT CHILD ELEMENTS THAT ARE BLOC ELEMENTS 
        AND DISPLAYS THEM SIDE BY SIDE
    */
    display: flex;
    /* 
        hero/jumbotron banner background. 
        uses the CSS function url() to link a resource such as an image, 
        web font, or GIF. Here we're using a relative URL path to select 
        a background image.
    */
    background-image: url(../images/hero-bg.jpg); 
    /* 
        The background-size property can set the size of the background 
        image to its original size or make it stretched, repeated, 
        or constrained to fit the available space. 
        In this case, we'll set it to cover to shrink the image so that parts
        of it won't get clipped.
    */
    background-size: cover;
    /* 
        The background-position property can set the initial position of 
        the background image. We'll set this position to center.
    */
    background-position: center;

    /* 
    To enable the absolute positioning of the form container to be taken 
    relative to the hero section, we need to make the hero section's 
    position relative.

    position: relative;
    REPLACED WITH FLEXBOX
    */

    /* We set justify-content to center because we want these two 
    boxes as close to the middle of the screen as possible.
    
    */
    justify-content: center;
    flex-wrap: wrap;
    
}

/* Text next to form in hero, call to action */

.hero-cta {
    width: 35%;
    text-align: right;
    margin: 3.5%;
    color: #fff;
    font-size: 18px;
    line-height: 1.3;
}

.hero-cta h2 {
    font-style: italic;
    font-size: 55px;
    color: #fce138;
}

.hero-form {
    color: #024e76;
    background-color: #fce138;
    width: 40%;
    margin: 3.5%;
    /* The padding property creates an inner margin within the border. */
    padding: 20px;
    border: solid 3px #024e76;

    /* 
    If we choose relative, we'd need to move the form container from its 
    current position and offset it from the left and top positions until we 
    found the correct spot according to the mock-up. But if we choose absolute, 
    we can use the parent container's margins to offset horizontally or vertically. 
    We'll use this option because the position of the form container is in 
    relation to the hero container.

    Let's start by assuming we'd like to offset the form container from 
    the bottom and right margins of the hero section (because the form 
    container will reside in the bottom right quadrant of the hero section).
    Then we add pixels to offset it away from the bottom right.

    width: 600px;
    position: absolute;
    bottom: 120px;
    right: 140px;
    REPLACED WITH FLEXBOX
    */

    
}

/* Targets "Get started today" */
.hero-form h3 {
    font-size: 24px;
    margin: 0;
}

/* everything separated by p tags in hero form, adds more top and bottom 
space between them */
.hero-form p {
    margin: 5px 0 15px 0;
}

/* Affect the first 3 input boxes on the form */
.form-input {
    font-size: 16px;
    border: 1px solid #024e76;
    /* one on each line */
    display: block;
    /* give the box more space padding inside */
    padding: 7px 15px;
    color: #024e76;
    /* Increases space between input box to element below it, also 
    increases parent's box size */
    margin-bottom: 15px;
    /* the inputs inherit margin from "section" selector above, thats why they dont
    touch the sides of the box when width = 100%. width percentage is 
    relative to the parent container's size */
    width: 100%;

}

/* labels above input fields in the form */
.hero-form label {
    margin: 0 5px;
}

/* Get running submit button */
.hero-form button {
    background-color: #024e76;
    color: #fce138;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
}

/* what we do section */




.intro p {
  line-height: 1.7;
  color: #39a6b2;
  width: 80%;
  font-size: 20px;
  /* centers an element with a width less than 100% 
  automatically on the left and right. Essentially, it tells the 
  browser to calculate the margins for us. When the browser is asked 
  to do this on both sides of an element, it will do its best to make 
  them even, thus pushing the element into the center. */
  margin: 0 auto;
  text-align: center;
}

/* what you do section */

/* container that incapsulates all of the steps */
.steps {
    background: #fce138;
}

/* each individual step box. step 1-4 */
.step {
    margin: 50px auto;
    padding-bottom: 50px;
    width: 80%;
    border-bottom: 1px solid #39a6b2;
    /* turns step name h3, and step-info div into flex items. 
    Those are the 2 direct children of step.
    */
    display: flex;
    flex-wrap: wrap;
    /* Step h3 is now vertically in the center of the box.
    if align items was default, the "step 1 or step 2..."
    would be at the top of the box.
    */
    align-items: center;
    /* empty space from the 80% width is now put between the children.
    h3 and step-info 
    */
    justify-content: space-between;

}

.step h3 {
  color: #024e76;
  font-size: 46px;
  /* see google docs flexbox */
  /* The value we provided to the step's flexbox children uses 
  the <flex-grow value> <flex-basis value> syntax, meaning 
  that .step h3 will be at least 30% wide and will receive any extra 
  space in the container. Also, .step-info will be at least 70% wide 
  but will receive any extra space in the container at a 2-to-1 ratio. 
  In other words, it will receive two more units of unused space than a 
  sibling with a flex-grow value of 1.

  */
  flex: 1 30%;
}

.step-info{
    /* see google docs flexbox */
    /* The value we provided to the step's flexbox children uses 
    the <flex-grow value> <flex-basis value> syntax, meaning 
    that .step h3 will be at least 30% wide and will receive any extra 
    space in the container. Also, .step-info will be at least 70% wide 
    but will receive any extra space in the container at a 2-to-1 ratio. 
    In other words, it will receive two more units of unused space than a 
    sibling with a flex-grow value of 1 
    */
    flex: 2 70%;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
}

.step-img {
    flex: 1 12%;
    margin-right: 20px;
}

.step-text {
    /* Now the child elements have a flex-grow property of 1 and 12, 
    respectively. This means that .step-text will be 
    allotted 12 times more unused space than .step-img, but .step-img 
    at the very least must be 12 percent of the width of .step-info.
    You usually comne across good proportion values by trial and error
    in Chrome's DevTools
    */
    flex: 12;
}

.step-img img {
    /* One last thing we need to do is tell the <img> element to limit 
    its width to be whatever its container is (step-img). This isn't a 
    problem with most browsers, but Microsoft Edge can be a little buggy 
    with it, so it's always worth putting in a little extra to have a 
    uniform design across browsers. 
    */
    max-width: 100%;
}

.step-text h4 {
    font-size: 26px;
    line-height: 1.5;
    color: #024e76;
}

.step-text p {
  color: #39a6b2;
  font-size: 18px;
}


/* can be used for all h2 headings such as what you do and what we do */
.section-title {
    font-size: 55px;
    color: #024e76;
    border-bottom: 3px solid;
    /* We chose to use the inline-block value instead of the inline 
    value so it can have the best of both worlds. It's now an inline element, 
    but things like padding still behave like they would on block elements. 
    Coupled with the text-align property from before, we now have a 
    center-aligned heading with an appropriately sized bottom border that 
    doesnt take up the whole width

    display: inline-block;
    margin-bottom: 35px;
    padding: 0 100px 20px 100px;
    REPLACED WITH FLEXBOX
    */

    /* center section titles and adjust margin and padding  */
    padding-bottom: 20px;
    text-align: center;
    margin: 0 auto 35px auto;
    width: 50%;
    
}

/* border color below h2 headings */
.primary-border {
    border-color: #fce138;
}

.secondary-border {
    border-color: #39a6b2;
}

/* meet the trainers section */

/* Container that incapsulates all trainer cards */
.trainers {
    width: 100%;
    margin: 0 auto;
    /* turns trainer cards into flex itema in a row */
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
}

/* individual article element per trainer */
.trainer {
    margin: 20px;
    background: #024e76;
    color: #fce138;
    /* We've used floats before to manipulate a page's default "flow," but in those cases we only floated one element. When we floated the <nav> element inside the <header>, the <header> lost its ability to interpret how much room the <nav> element needed. This was okay, though, because the <header> still was able to interpret how much space the <h1> element needed because it wasn't floated and the <header> displayed at the correct size.

In this case, however, we floated both elements (the <img> and <div>). This meant that the parent element—the <article> element—couldn't interpret how much space its inner HTML content needed and thus assumed there was nothing inside it. This caused the <article> element's styles to not display, because the <article> element itself is 0px tall.

This a common issue for float-based layouts. It involves not only moving the elements we want to move, but also tweaking surrounding elements to account for other floated elements. There are a few ways to fix this problem—we chose the overflow property. 

The overflow property told the trainer's <article> element that it does in fact have content inside it, and that it needs to look for it and account for those two floated HTML elements' sizes. This is known as providing block formatting context to the element.

overflow: auto;
REPLACED WITH FLEXBOX
*/

/* all trainers are placed 1 to 1 to 1. share the space as equally as possible */
flex: 1;
}

.trainer img {
    width: 100%; 
}

.trainer-bio {
    padding: 25px;
    line-height: 1.3;
}



.trainer-bio h3 {
    font-size: 28px;
}

.trainer-bio h4 {
    font-weight: lighter;
    font-size: 22px;
    margin-bottom: 15px;
}

.trainer-bio p {
    font-size: 17px;
}

/* reach out section */

.contact {
    background: #024e76;
}

.contact h2 {
    color: #fce138;
}

/* Container incapsulating all maps and contact info in reaach out */
.contact-info {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

/* Here, the * selector is saying "select all elements that are 
direct children of anything with a class of contact-info." The > symbol 
means it's looking specifically for direct children of the element.

We are doing this because we want to space the elements within the contact-info
flexbox evenly. But the elements within contact-info are all different element types.
So instaed of giving them all the same class, we targeted them all this way.
In this case, we are applying all the styles within the brackets to the 3
elements that are the direct children of contact-info.
*/
.contact-info > * {
    /* makes all direct children share the space equally */
    flex: 1;
    margin: 15px;
}

.contact-info iframe {
    height: 400px;
}

/* div inside of contact info (the address text) */
.contact-info div {
    color: white;
}

.contact-info h3 {
    color: #fce138;
    font-size: 32px;
}

/* targets 2 different selectors and gives them the same attributes */
.contact-info p, .contact-info address {
    margin: 20px 0;
    line-height: 1.5;
    font-size: 16px;
    /* since by default, address elements italicize the text */
    font-style: normal;
}

.contact-form input, .contact-form textarea {
    border: 1px solid #024e76;
    display: block;
    padding: 7px 15px;
    font-size: 16px;
    color: #024e76;
    width: 100%;
    margin-bottom: 15px;
    margin-top: 5px;
}

.contact-form button {
    width: 100%;
    border: none;
    background: #fce138;
    color: #024e76;
    text-align: center;
    padding: 15px 0;
    font-size: 16px;
}

.contact-info a {
    color: #fce138;
}

/* Utility classes */

.text-left {
    text-align: left;
}

.text-right {
    text-align: right;
}

.flex-row {
    display: flex;
}