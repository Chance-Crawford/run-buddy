

/* the universal selector, 
and it sets a style for all of the elements 
of an HTML page. */
* {
    /* browsers put padding and margin on many elements by default,
    this takes all of that off at the beginning */
    margin: 0;
    padding: 0;

    /* The border-box value calculates the height and 
    width of the element
     by including the border and padding additions 
     to the content box. Helps keep content from going
     off the screen*/
    box-sizing: border-box;
}


body {
    color: #39a6b2;
    font-family: Helvetica, Arial, sans-serif;
    
}

/* header style */

header {
    /* padding top bottom, left right */
    padding: 20px 35px;
    background-color: #39a6b2;
    /* check google docs css flexbox. This makes all direct child elements
    of the header (h1, nav) flex items in the header.
    Adding flexbox can override the behavior of block elements, and 
    display them side by side. overrides display property and changes direct 
    child elements to "flex"
    */
    display: flex;
    /* google docs css flexbox, this property can only be used when the
    display value of the element or parent element is flex.
    This property declaration puts all of the unused space in 
    the <header> between the two elements, with the space-between value. 
    It determines the unused space by adding up the border-width, margin, 
    padding, and content of each child element. If these don't add up to 100% 
    of the parent, then whatever is left over is considered unused.
    */
    justify-content: space-between;
    /* By default, the value of flex-wrap is set to none, so we need 
    to explicitly tell it to wrap to the next line if the screen width is smaller
    or the child elements are too big for the screen.

    This will cause the nav element to break to the next line on smaller screens, 
    but all the nav
    items break in weird places. We can change this in the nav ul element css
    */
    flex-wrap: wrap;
}

header h1 {
    font-weight: bold;
    font-size: 36px;
    color: #fce138;
    margin: 0;
}

header a {
    text-decoration: none;
    color: #fce138;
}

header nav {
    margin: 7px 0;
}

header nav ul {
    /* makes the li items go side by side, turns into flex items,
    since they are direct children of the ul element
    */
    display: flex;
    /* if screen is small (mobile) wrap content to other line if needed */
    flex-wrap: wrap;
    justify-content: space-between;
    /* vertically center the content for smaller screens */
    align-items: center;
    /* The other property we added, list-style, sets how 
    a list item is styled (bullet points, dashes, etc.) and positioned 
    (indented or outdented). We gave it a value of none to hide 
    the bullet points, because we're changing some of the styles 
    for the <header>. These changes might make the bullet points visible, 
    which we don't want. 
    */
    list-style: none;
}

header nav ul li a {
    margin: 0 30px;
    font-weight: lighter;
    /* vw stands for viewport width. Font size is determined by the width
    of the viewport. In this case we want the font size to be roughly
    1.55% of the windows overall width. This means that if the browser grows 
    or shrinks, that size will change relative to the new overall width.
    */
    font-size: 1.55vw;
}

/* footer style */

footer {
    background: #fce138;
    width: 100%;
    padding: 40px 35px;
}

footer h2 {
    display: inline;
    color: #024e76;
    font-size: 30px;
    margin: 0;
}

footer div {
    float: right;
    /* vertical space between lines of text */
    line-height: 1.5; 
    text-align: right;
}

footer a {
    color: #024e76;
}

section {
    padding: 60px;
}

/* Hero style start */
.hero {
    /* 
        The height property fixed at 600px gives an exact size 
        of the section, which is important in this context to allow 
        room for the sign-up form.
    */
    height: 600px;
    /* 
        hero/jumbotron banner background. 
        uses the CSS function url() to link a resource such as an image, 
        web font, or GIF. Here we're using a relative URL path to select 
        a background image.
    */
    background-image: url(../images/hero-bg.jpg); 
    /* 
        The background-size property can set the size of the background 
        image to its original size or make it stretched, repeated, 
        or constrained to fit the available space. 
        In this case, we'll set it to cover to shrink the image so that parts
        of it won't get clipped.
    */
    background-size: cover;
    /* 
        The background-position property can set the initial position of 
        the background image. We'll set this position to center.
    */
    background-position: center;

    /* 
    To enable the absolute positioning of the form container to be taken 
    relative to the hero section, we need to make the hero section's 
    position relative.
    */

    position: relative;
}
/* Hero styloe end */

.hero-form {
    color: #024e76;
    background-color: #fce138;
    width: 500px;
    /* The padding property creates an inner margin within the border. */
    padding: 20px;
    border: solid 3px #024e76;

    /* 
    If we choose relative, we'd need to move the form container from its 
    current position and offset it from the left and top positions until we 
    found the correct spot according to the mock-up. But if we choose absolute, 
    we can use the parent container's margins to offset horizontally or vertically. 
    We'll use this option because the position of the form container is in 
    relation to the hero container.

    Let's start by assuming we'd like to offset the form container from 
    the bottom and right margins of the hero section (because the form 
    container will reside in the bottom right quadrant of the hero section).
    Then we add pixels to offset it away from the bottom right.
    */
    
    position: absolute;
    bottom: 120px;
    right: 140px;
}

/* Targets "Get started today" */
.hero-form h3 {
    font-size: 24px;
    margin: 0;
}

/* everything separated by p tags in hero form, adds more top and bottom 
space between them */
.hero-form p {
    margin: 5px 0 15px 0;
}

/* Affect the first 3 input boxes on the form */
.form-input {
    font-size: 16px;
    border: 1px solid #024e76;
    /* one on each line */
    display: block;
    /* give the box more space padding inside */
    padding: 7px 15px;
    color: #024e76;
    /* Increases space between input box to element below it, also 
    increases parent's box size */
    margin-bottom: 15px;
    /* the inputs inherit margin from "section" selector above, thats why they dont
    touch the sides of the box when width = 100%. width percentage is 
    relative to the parent container's size */
    width: 100%;

}

/* labels above input fields in the form */
.hero-form label {
    margin: 0 5px;
}

/* Get running submit button */
.hero-form button {
    background-color: #024e76;
    color: #fce138;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
}

/* what we do section */

.intro {
    text-align: center;
}


.intro p {
  line-height: 1.7;
  color: #39a6b2;
  width: 80%;
  font-size: 20px;
  /* centers an element with a width less than 100% 
  automatically on the left and right. Essentially, it tells the 
  browser to calculate the margins for us. When the browser is asked 
  to do this on both sides of an element, it will do its best to make 
  them even, thus pushing the element into the center. */
  margin: 0 auto;
}

/* what you do section */

.steps {
    text-align: center;
    background: #fce138;
}

.steps div {
    margin-bottom: 80px;
}

.steps img {
    /* makes icons a lot smaller */
    width: 15%;
    margin: 10px 0;
}

.steps h3 {
  color: #024e76;
  font-size: 46px;
  margin-top: 10px;
}

.steps p {
  color: #39a6b2;
  font-size: 23px;
}

/* makes text slightly smaller */
.steps span {
    font-size: 38px;
}

/* can be used for all h2 headings such as what you do and what we do */
.section-title {
    font-size: 55px;
    color: #024e76;
    margin-bottom: 35px;
    padding: 0 100px 20px 100px;
    border-bottom: 3px solid;
    /* We chose to use the inline-block value instead of the inline 
    value so it can have the best of both worlds. It's now an inline element, 
    but things like padding still behave like they would on block elements. 
    Coupled with the text-align property from before, we now have a 
    center-aligned heading with an appropriately sized bottom border that 
    doesnt take up the whole width*/
    display: inline-block;
}

/* border color below h2 headings */
.primary-border {
    border-color: #fce138;
}

.secondary-border {
    border-color: #39a6b2;
}

/* meet the trainers section */

.trainers {
    text-align: center;
}

/* individual article element per trainer */
.trainer {
    width: 900px;
    margin: 0 auto 30px auto;
    background: #024e76;
    color: #fce138;
    /* We've used floats before to manipulate a page's default "flow," but in those cases we only floated one element. When we floated the <nav> element inside the <header>, the <header> lost its ability to interpret how much room the <nav> element needed. This was okay, though, because the <header> still was able to interpret how much space the <h1> element needed because it wasn't floated and the <header> displayed at the correct size.

In this case, however, we floated both elements (the <img> and <div>). This meant that the parent element—the <article> element—couldn't interpret how much space its inner HTML content needed and thus assumed there was nothing inside it. This caused the <article> element's styles to not display, because the <article> element itself is 0px tall.

This a common issue for float-based layouts. It involves not only moving the elements we want to move, but also tweaking surrounding elements to account for other floated elements. There are a few ways to fix this problem—we chose the overflow property. 

The overflow property told the trainer's <article> element that it does in fact have content inside it, and that it needs to look for it and account for those two floated HTML elements' sizes. This is known as providing block formatting context to the element.
*/
    overflow: auto;

}

.trainer img {
    /* 35% of the box which now has a width of 900 */
    width: 35%; 
    float: left;
}

.trainer-bio {
    padding: 35px;
    float: left;
    width: 65%;
}

.text-left {
    text-align: left;
}

.text-right {
    text-align: right;
}

.trainer-bio h3 {
    font-size: 32px;
    margin-bottom: 8px;
}

.trainer-bio h4 {
    font-weight: lighter;
    font-size: 26px;
    margin-bottom: 25px;
}

.trainer-bio p {
    font-size: 17px;
    line-height: 1.3;
}

/* reach out section */

.contact {
    background: #024e76;
    text-align: center;
}

.contact h2 {
    color: #fce138;
}

.contact-info iframe {
    width: 400px;
    height: 400px;
}

/* div inside of contact info (the address text) */
.contact-info div {
    width: 410px;
    /* 
    This allows the .contact-info container to sit on the 
    same row as the <iframe> element and allows us to assign a 
    width, something that the property value inline wouldn't let us do.
    */
    display: inline-block;
    /* 
    Because the content of this <div> naturally rests at the bottom of 
    the container, we need the vertical-align property to lift this 
    content up to the top.
    */
    vertical-align: top;
    text-align: left;
    margin: 30px 0 0 60px;
    color: white;
}

.contact-info h3 {
    color: #fce138;
    font-size: 32px;
}

/* targets 2 different selectors and gives them the same attributes */
.contact-info p, .contact-info address {
    margin: 20px 0;
    line-height: 1.5;
    font-size: 20px;
    /* since by default, address elements italicize the text */
    font-style: normal;
}

.contact-info a {
    color: #fce138;
}